---
layout: post
title:  okhttp内核剖析
date:   2019-08-16 1:05:00
catalog:  true
tags:
    - okhttp 
             
       

---


<div data-note-content="" class="show-content">
          <div class="show-content-free">
            <p><a href="https://link.jianshu.com?t=http://zhushou.360.cn/detail/index/soft_id/3850966" target="_blank" rel="nofollow">Android程序员面试宝典</a></p>
<p>okhttp源码特别特别复杂，类涉及较多，导致本文非常长，我相信没有几个人能把本文看完，所以特意录制了跟文章同步的视频。</p>
<h3>自定义控件</h3>
<ul>
<li><a href="https://www.jianshu.com/p/4a16d831c574" target="_blank">一分钟实现贴纸功能</a></li>
<li><a href="https://www.jianshu.com/p/e25ac7dccf12" target="_blank">一分钟实现TextView高亮</a></li>
<li><a href="https://www.jianshu.com/p/b21753a100c4" target="_blank">一分钟实现新手引导页</a></li>
<li><a href="https://www.jianshu.com/p/c4f9f5ccc0e1" target="_blank">一分钟实现ViewPager卡片</a></li>
<li><a href="https://www.jianshu.com/p/f847325e8a28" target="_blank">一分钟实现轮播图</a></li>
<li><a href="https://www.jianshu.com/p/80a423f662a4" target="_blank">一分钟实现GridView拖拽</a></li>
<li><a href="https://www.jianshu.com/p/c94584b72635" target="_blank">一分钟实现底部导航栏</a></li>
<li><a href="https://www.jianshu.com/p/dd5cbc6544a9" target="_blank">一分钟实现底部FragmentTabhost</a></li>
<li><a href="https://www.jianshu.com/p/942bf1aa9618" target="_blank">一分钟实现多张图片选择</a></li>
<li><a href="https://www.jianshu.com/p/2a830d089310" target="_blank">一分钟实现仿美拍直播的点赞动画</a></li>
<li><a href="https://www.jianshu.com/p/618a5820261c" target="_blank">一分钟实现高仿今日头条视频列表</a></li>
<li><a href="https://www.jianshu.com/p/be3d0f763c5a" target="_blank">一分钟实现购物车加减控件</a></li>
<li><a href="https://www.jianshu.com/p/979983c6b0fe" target="_blank">一分钟实现省市县三级联动</a></li>
<li><a href="https://www.jianshu.com/p/42c71b973011" target="_blank">一分钟实现二维码生成和扫描</a></li>
<li><a href="https://www.jianshu.com/p/7d4bb19da45d" target="_blank">一分钟实现沉浸式状态栏</a></li>
<li><a href="https://www.jianshu.com/p/998c88aebed1" target="_blank">一分钟实现图片裁剪</a></li>
<li><a href="https://www.jianshu.com/p/d8697b64591f" target="_blank">一分钟实现视频弹幕</a></li>
<li><a href="https://www.jianshu.com/p/68d24080d320" target="_blank">一分钟实现图片缩放</a></li>
<li><a href="https://www.jianshu.com/p/88ebcdc21d66" target="_blank">一分钟实现旋转选择器</a></li>
<li><a href="https://www.jianshu.com/p/b2847a18046b" target="_blank">一分钟实现ofo小黄车的引导界面</a></li>
<li><a href="https://www.jianshu.com/p/54da154b8cad" target="_blank">一分钟实现自定义ImageView外貌</a></li>
<li><a href="https://www.jianshu.com/p/3c3738bc8de9" target="_blank">一分钟实现向左拖拽跳转详情页</a></li>
<li><a href="https://www.jianshu.com/p/b1ec86868dd5" target="_blank">一分钟实现QQ首页动画特效</a></li>
<li><a href="https://www.jianshu.com/p/b1ec86868dd5" target="_blank">一分钟实现ViewPager上下滑动</a></li>
</ul>
<h3>联网</h3>
<ul>
<li><a href="https://www.jianshu.com/p/bd746ab64fbe" target="_blank">一分钟学会Retrofit并且进行实战</a></li>
<li><a href="https://www.jianshu.com/p/e9258c1bc5ce" target="_blank">一分钟实现OkHttp3</a></li>
</ul>
<h3>工具</h3>
<ul>
<li><a href="https://www.jianshu.com/p/0277786f60d6" target="_blank">一分钟实现RecyclerView</a></li>
<li><a href="https://www.jianshu.com/p/aafd34fa5711" target="_blank">一分钟实现H5和Android通信</a></li>
<li><a href="https://www.jianshu.com/p/dcf04101f268" target="_blank">一分钟实现pinyin4j</a></li>
<li><a href="https://www.jianshu.com/p/3af69eecfab4" target="_blank">一分钟实现分析内存泄漏</a></li>
</ul>
<h3>数据库</h3>
<ul>
<li><a href="https://www.jianshu.com/p/2cca2f5c9737" target="_blank">一分钟实现LitePal数据库</a></li>
<li><a href="https://www.jianshu.com/p/231027465aab" target="_blank">一分钟实现ormlite数据库</a></li>
<li><a href="https://www.jianshu.com/p/04db4325ae82" target="_blank">一分钟实现GreenDao数据库</a></li>
</ul>
<h3>源码分析相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/ec3dc92df581" target="_blank">Volley源码分析</a></li>
<li><a href="https://www.jianshu.com/p/20da6d6389e1" target="_blank">注解框架实现原理</a></li>
<li><a href="https://www.jianshu.com/p/9ed2c2f2a52c" target="_blank">okhttp3.0源码分析</a></li>
<li><a href="https://www.jianshu.com/p/cbf9c3557d64" target="_blank">onSaveInstanceState源码分析</a></li>
<li><a href="https://www.jianshu.com/p/2211a5b3c37f" target="_blank">静默安装和源码编译</a></li>
</ul>
<h3>Activity相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/cbf9c3557d64" target="_blank">保存Activity的状态</a></li>
<li><a href="https://www.jianshu.com/p/b33fd8c550bf" target="_blank">深刻剖析activity启动模式(一)</a></li>
<li><a href="https://www.jianshu.com/p/e1ea9e542112" target="_blank">深刻剖析activity启动模式(二)</a></li>
<li><a href="https://www.jianshu.com/p/d13e3d552d4b" target="_blank">深刻剖析activity启动模式(三)</a></li>
<li><a href="https://www.jianshu.com/p/d13e3d552d4b" target="_blank">Activity Task和Process之间的关系</a></li>
<li><a href="https://www.jianshu.com/p/16e880ceb3a4" target="_blank">源码分析service开启Activity抛异常？activity不会抛异常</a></li>
<li><a href="https://www.jianshu.com/p/197cb31bdb37" target="_blank">Activity优雅退出</a></li>
<li><a href="https://www.jianshu.com/p/89f350c0db62" target="_blank">onCreate源码分析</a></li>
</ul>
<h3>Service相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/62a22dc70048" target="_blank">IntentService源码分析</a></li>
<li><a href="https://www.jianshu.com/p/24685c806108" target="_blank">Service是否在main thread中执行, service里面是否能执行耗时的操作?</a></li>
<li><a href="https://www.jianshu.com/p/74da24a06308" target="_blank">Service不死之身</a></li>
</ul>
<h3>与XMPP相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/2c04ac3c526a" target="_blank">XMPP协议优缺点</a></li>
<li><a href="https://www.jianshu.com/p/d88dc66908cf" target="_blank">极光消息推送原理</a></li>
</ul>
<h3>与性能优化相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/5dd645b05c76" target="_blank">内存泄漏和内存溢出区别</a></li>
<li><a href="https://www.jianshu.com/p/c22398f8587f" target="_blank">UI优化和线程池实现原理</a></li>
<li><a href="https://www.jianshu.com/p/ebd41eab90df" target="_blank">代码优化</a></li>
<li><a href="https://www.jianshu.com/p/2665c31b9c2f" target="_blank">内存性能分析</a></li>
<li><a href="https://www.jianshu.com/p/1514c7804a06" target="_blank">内存泄漏检测</a></li>
<li><a href="https://www.jianshu.com/p/f0f73fefdd43" target="_blank">App启动优化</a></li>
<li><a href="https://www.jianshu.com/p/de4793a4c2d0" target="_blank">与IPC机制相关面试题</a></li>
</ul>
<h3>与登录相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/2a6ecbf8d49d" target="_blank">oauth认证协议原理</a></li>
<li><a href="https://www.jianshu.com/p/9b7ce2d6c195" target="_blank">token产生的意义</a></li>
<li><a href="https://www.jianshu.com/p/a9d1f21bd5e0" target="_blank">微信扫一扫实现原理</a></li>
</ul>
<h3>与开发相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/cbecadec98de" target="_blank">迭代开发的时候如何向前兼容新旧接口</a></li>
<li><a href="https://www.jianshu.com/p/30fdc391289c" target="_blank">手把手教你如何解决as jar包冲突</a></li>
<li><a href="https://www.jianshu.com/p/2706c13a1769" target="_blank">context的原理分析</a></li>
<li><a href="https://www.jianshu.com/p/38ab6d856b56" target="_blank">解决ViewPager.setCurrentItem中间很多页面切换方案</a></li>
<li><a href="https://www.jianshu.com/p/33d499170e25" target="_blank">字体适配</a></li>
<li><a href="https://www.jianshu.com/p/640bac6f58ab" target="_blank">软键盘适配</a></li>
<li><a href="https://www.jianshu.com/p/2b6ac837a173" target="_blank">机型适配，例如三星、小米、华为、魅族等</a></li>
<li><a href="https://www.jianshu.com/p/e429bb41bdb6" target="_blank">CardView 设置水波纹效果</a></li>
</ul>
<h3>与人事相关面试题</h3>
<ul>
<li><a href="https://www.jianshu.com/p/d61b553ff8c9" target="_blank">人事面试宝典</a></li>
</ul>
<h3>本文配套视频：</h3>
<ul>
<li><a href="https://link.jianshu.com?t=http://www.toutiao.com/i6431810232636146178/" target="_blank" rel="nofollow">okhttp内核分析配套视频一</a></li>
<li><a href="https://link.jianshu.com?t=http://www.toutiao.com/i6431721169245700609/" target="_blank" rel="nofollow">okhttp内核分析配套视频二</a></li>
<li><a href="https://link.jianshu.com?t=http://www.toutiao.com/i6431721981959209473/" target="_blank" rel="nofollow">okhttp内核分析配套视频三</a></li>
</ul>
<h4>基本使用</h4>
<p>从使用方法出发，首先是怎么使用，其次是我们使用的功能在内部是如何实现的.建议大家下载 OkHttp 源码之后，跟着本文，过一遍源码。<br>
通过小栗子开启今天的源码分析：</p>
<pre class="hljs cpp"><code class="cpp">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();

<span class="hljs-function">String <span class="hljs-title">run</span><span class="hljs-params">(String url)</span> throws IOException </span>{
  Request request = <span class="hljs-keyword">new</span> Request.Builder()
      .url(url)
      .build();

  Response response = client.newCall(request).execute();
  <span class="hljs-keyword">return</span> response.body().<span class="hljs-built_in">string</span>();
}
</code></pre>
<h3>Request、Response、Call 基本概念</h3>
<p>上面的代码中涉及到几个常用的类：Request、Response和Call。下面分别介绍：</p>
<h4>Request</h4>
<p>每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。</p>
<h4>Response</h4>
<p>响应是对请求的回复，包含状态码、HTTP头和主体部分。</p>
<h4>Call</h4>
<p>OkHttp使用Call抽象出一个满足请求的模型，尽管中间可能会有多个请求或响应。执行Call有两种方式，同步或异步</p>
<h3>第一步：创建 OkHttpClient对象,进行源码分析：</h3>
<pre class="hljs cpp"><code class="cpp">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();`
</code></pre>
<p>通过okhttp源码分析,直接创建的 OkHttpClient对象并且默认构造builder对象进行初始化</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OkHttpClient</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> Builder());
  }
  OkHttpClient(Builder builder) {
    <span class="hljs-keyword">this</span>.dispatcher = builder.dispatcher;
    <span class="hljs-keyword">this</span>.proxy = builder.proxy;
    <span class="hljs-keyword">this</span>.protocols = builder.protocols;
    <span class="hljs-keyword">this</span>.connectionSpecs = builder.connectionSpecs;
    <span class="hljs-keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);
    <span class="hljs-keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);
    <span class="hljs-keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;
    <span class="hljs-keyword">this</span>.proxySelector = builder.proxySelector;
    <span class="hljs-keyword">this</span>.cookieJar = builder.cookieJar;
    <span class="hljs-keyword">this</span>.cache = builder.cache;
    <span class="hljs-keyword">this</span>.internalCache = builder.internalCache;
    <span class="hljs-keyword">this</span>.socketFactory = builder.socketFactory;

    <span class="hljs-keyword">boolean</span> isTLS = <span class="hljs-keyword">false</span>;
    ......

    <span class="hljs-keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;
    <span class="hljs-keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
        certificateChainCleaner);
    <span class="hljs-keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;
    <span class="hljs-keyword">this</span>.authenticator = builder.authenticator;
    <span class="hljs-keyword">this</span>.connectionPool = builder.connectionPool;
    <span class="hljs-keyword">this</span>.dns = builder.dns;
    <span class="hljs-keyword">this</span>.followSslRedirects = builder.followSslRedirects;
    <span class="hljs-keyword">this</span>.followRedirects = builder.followRedirects;
    <span class="hljs-keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;
    <span class="hljs-keyword">this</span>.connectTimeout = builder.connectTimeout;
    <span class="hljs-keyword">this</span>.readTimeout = builder.readTimeout;
    <span class="hljs-keyword">this</span>.writeTimeout = builder.writeTimeout;
    <span class="hljs-keyword">this</span>.pingInterval = builder.pingInterval;
  }
}
</code></pre>
<h3>第二步：接下来发起 HTTP 请求</h3>
<pre class="hljs java"><code class="java">Request request = <span class="hljs-keyword">new</span> Request.Builder().url(<span class="hljs-string">"url"</span>).build();
okHttpClient.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>{

 }

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>{

}
});
</code></pre>
<h3>第二步：代码流程分析：</h3>
<pre class="hljs cpp"><code class="cpp">Request request = <span class="hljs-keyword">new</span> Request.Builder().url(<span class="hljs-string">"url"</span>).build();
</code></pre>
<p>初始化构建者模式和请求对象，并且用URL替换Web套接字URL。</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.method = <span class="hljs-string">"GET"</span>;
      <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> Headers.Builder();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">url</span><span class="hljs-params">(String url)</span> </span>{
      ......

      <span class="hljs-comment">// Silently replace web socket URLs with HTTP URLs.</span>
      <span class="hljs-keyword">if</span> (url.regionMatches(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"ws:"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)) {
        url = <span class="hljs-string">"http:"</span> + url.substring(<span class="hljs-number">3</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url.regionMatches(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"wss:"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)) {
        url = <span class="hljs-string">"https:"</span> + url.substring(<span class="hljs-number">4</span>);
      }

      HttpUrl parsed = HttpUrl.parse(url);
      ......
      <span class="hljs-keyword">return</span> url(parsed);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{
      ......
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(<span class="hljs-keyword">this</span>);
    }
}
</code></pre>
<h3>第三步：方法解析：</h3>
<pre class="hljs java"><code class="java">okHttpClient.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>{

}

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>{

}
});
</code></pre>
<p>源码分析：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> </span>{
   <span class="hljs-meta">@Override</span> 
   <span class="hljs-function"><span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);
   }



}
</code></pre>
<p>RealCall实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p>
<h3>异步请求的执行流程</h3>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span> </span>{
   <span class="hljs-meta">@Override</span> 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> </span>{
   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
   <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);
      executed = <span class="hljs-keyword">true</span>;
   }
    captureCallStackTrace();
    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));
  }
}
</code></pre>
<h3>由以上源码得知：</h3>
<p>1） 检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 call#clone 方法进行克隆。</p>
<p>2）利用 client.dispatcher().enqueue(this) 来进行实际执行，dispatcher 是刚才看到的 OkHttpClient.Builder 的成员之一</p>
<p>3）AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
  ......

  <span class="hljs-meta">@Override</span> 
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
   ......
    <span class="hljs-keyword">try</span> {
      execute();
    }
    ......
  }

  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p>可以看到NamedRunnable实现了Runnbale接口并且是个抽象类，其抽象方法是execute()，该方法是在run方法中被调用的，这也就意味着NamedRunnable是一个任务，并且其子类应该实现execute方法。下面再看AsyncCall的实现：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedRunnable</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;

    AsyncCall(Callback responseCallback) {
      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());
      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;
    }

    ......
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span> </span>{
  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">try</span> {
     Response response = getResponseWithInterceptorChain();
  <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) {
     signalledCallback = <span class="hljs-keyword">true</span>;
     responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));
  } <span class="hljs-keyword">else</span> {
    signalledCallback = <span class="hljs-keyword">true</span>;
    responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);
  }
 } <span class="hljs-keyword">catch</span> (IOException e) {
  ......
  responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);
        
} <span class="hljs-keyword">finally</span> {
    client.dispatcher().finished(<span class="hljs-keyword">this</span>);
  }
}
</code></pre>
<p>AsyncCall实现了execute方法，首先是调用getResponseWithInterceptorChain()方法获取响应，然后获取成功后，就调用回调的onReponse方法，如果失败，就调用回调的onFailure方法。最后，调用Dispatcher的finished方法。</p>
<p>关键代码：</p>
<p>responseCallback.onFailure(RealCall.this, new IOException("Canceled"));</p>
<p>和</p>
<p>responseCallback.onResponse(RealCall.this, response);</p>
<p>走完这两句代码会进行回调到刚刚我们初始化Okhttp的地方,如下：</p>
<pre class="hljs java"><code class="java">okHttpClient.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>{

   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>{

   }
});
</code></pre>
<h3>核心重点类Dispatcher线程池介绍</h3>
<pre class="hljs php"><code class="php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatcher</span> </span>{
  <span class="hljs-comment">/** 最大并发请求数为64 */</span>
  <span class="hljs-keyword">private</span> int maxRequests = <span class="hljs-number">64</span>;
  <span class="hljs-comment">/** 每个主机最大请求数为5 */</span>
  <span class="hljs-keyword">private</span> int maxRequestsPerHost = <span class="hljs-number">5</span>;

  <span class="hljs-comment">/** 线程池 */</span>
  <span class="hljs-keyword">private</span> ExecutorService executorService;

  <span class="hljs-comment">/** 准备执行的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();

  <span class="hljs-comment">/** 正在执行的异步请求，包含已经取消但未执行完的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();

  <span class="hljs-comment">/** 正在执行的同步请求，包含已经取消单未执行完的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
</code></pre>
<p>在OkHttp，使用如下构造了单例线程池</p>
<pre class="hljs java"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title">executorService</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) {
      executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
          <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-keyword">false</span>));
    }
    <span class="hljs-keyword">return</span> executorService;
  }
</code></pre>
<p>构造一个线程池ExecutorService：</p>
<pre class="hljs cpp"><code class="cpp">executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
<span class="hljs-comment">//corePoolSize 最小并发线程数,如果是0的话，空闲一段时间后所有线程将全部被销毁</span>
    <span class="hljs-number">0</span>, 
<span class="hljs-comment">//maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</span>
    Integer.MAX_VALUE, 
<span class="hljs-comment">//keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间</span>
    <span class="hljs-number">60</span>, 
<span class="hljs-comment">//单位秒</span>
    TimeUnit.SECONDS,
<span class="hljs-comment">//工作队列,先进先出</span>
    <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),   
<span class="hljs-comment">//单个线程的工厂         </span>
   Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-literal">false</span>));
</code></pre>
<p>可以看出，在Okhttp中，构建了一个核心为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做"OkHttp Dispatcher"的线程工厂。</p>
<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>
<pre class="hljs java"><code class="java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(AsyncCall call)</span> </span>{
    <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
      runningAsyncCalls.add(call);
      executorService().execute(call);
    } <span class="hljs-keyword">else</span> {
      readyAsyncCalls.add(call);
    }
  }
</code></pre>
<p>从上述源码分析，如果当前还能执行一个并发请求，则加入 runningAsyncCalls ，立即执行，否则加入 readyAsyncCalls 队列。</p>
<h4>Dispatcher线程池总结</h4>
<p>1）调度线程池Disptcher实现了高并发，低阻塞的实现<br>
2）采用Deque作为缓存，先进先出的顺序执行<br>
3）任务在try/finally中调用了finished函数，控制任务队列的执行顺序，而不是采用锁，减少了编码复杂性提高性能</p>
<p>这里是分析OkHttp源码，并不详细讲线程池原理，如对线程池不了解请参考如下链接</p>
<p><a href="https://www.jianshu.com/p/c22398f8587f" target="_blank">点我，线程池原理，在文章性能优化最后有视频对线程池原理讲解</a></p>
<pre class="hljs java"><code class="java">
 <span class="hljs-keyword">try</span> {
        Response response = getResponseWithInterceptorChain();
        <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = <span class="hljs-keyword">true</span>;
          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));
        } <span class="hljs-keyword">else</span> {
          signalledCallback = <span class="hljs-keyword">true</span>;
          responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);
        }
      } <span class="hljs-keyword">finally</span> {
        client.dispatcher().finished(<span class="hljs-keyword">this</span>);
      }
</code></pre>
<p>当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数</p>
<pre class="hljs cpp"><code class="cpp"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(AsyncCall call)</span> </span>{
    finished(runningAsyncCalls, call, <span class="hljs-literal">true</span>);
  }


</code></pre>
<p>从上面的代码可以看出，第一个参数传入的是正在运行的异步队列，第三个参数为true，下面再看有是三个参数的finished方法：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(Deque&lt;T&gt; calls, T call, <span class="hljs-keyword">boolean</span> promoteCalls)</span> </span>{
    <span class="hljs-keyword">int</span> runningCallsCount;
    Runnable idleCallback;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Call wasn't in-flight!"</span>);
      <span class="hljs-keyword">if</span> (promoteCalls) promoteCalls();
      runningCallsCount = runningCallsCount();
      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;
    }

    <span class="hljs-keyword">if</span> (runningCallsCount == <span class="hljs-number">0</span> &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) {
      idleCallback.run();
    }
  }
</code></pre>
<p>打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，获取运行数量判断是否进入了Idle状态,接着执行promoteCalls()函数,下面是promoteCalls()方法：</p>
<pre class="hljs cpp"><code class="cpp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">promoteCalls</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Already running max capacity.</span>
    <span class="hljs-keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// No ready calls to promote.</span>

    <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
      AsyncCall call = i.next();

      <span class="hljs-keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) {
        i.remove();
        runningAsyncCalls.add(call);
        executorService().execute(call);
      }

      <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Reached max capacity.</span>
    }
  }
</code></pre>
<p>主要就是遍历等待队列，并且需要满足同一主机的请求小于maxRequestsPerHost时，就移到运行队列中并交给线程池运行。就主动的把缓存队列向前走了一步，而没有使用互斥锁等复杂编码</p>
<h3>核心重点getResponseWithInterceptorChain方法</h3>
<pre class="hljs java"><code class="java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-comment">// Build a full stack of interceptors.</span>
    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(<span class="hljs-keyword">new</span> BridgeInterceptor(client.cookieJar()));
    interceptors.add(<span class="hljs-keyword">new</span> CacheInterceptor(client.internalCache()));
    interceptors.add(<span class="hljs-keyword">new</span> ConnectInterceptor(client));
    <span class="hljs-keyword">if</span> (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(<span class="hljs-keyword">new</span> CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, originalRequest);
    <span class="hljs-keyword">return</span> chain.proceed(originalRequest);
  }
</code></pre>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 868px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 124.0%;"></div>
<div class="image-view" data-width="700" data-height="868"><img data-original-src="//upload-images.jianshu.io/upload_images/4037105-e7f17417cf6fa30a" data-original-width="700" data-original-height="868" data-original-format="image/png" data-original-filesize="102888" style="cursor: zoom-in;" class="" src="//upload-images.jianshu.io/upload_images/4037105-e7f17417cf6fa30a?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp"></div>
</div>
<div class="image-caption"></div>
</div>
<p>1）在配置 OkHttpClient 时设置的 interceptors；<br>
2）负责失败重试以及重定向的 RetryAndFollowUpInterceptor；<br>
3）负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；<br>
4）负责读取缓存直接返回、更新缓存的 CacheInterceptor；<br>
5）负责和服务器建立连接的 ConnectInterceptor；<br>
6）配置 OkHttpClient 时设置的 networkInterceptors；<br>
7）负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。</p>
<p>OkHttp的这种拦截器链采用的是责任链模式，这样的好处是将请求的发送和处理分开，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p>
<p>从上述源码得知，不管okhttp有多少拦截器最后都会走，如下方法：</p>
<pre class="hljs java"><code class="java">Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, originalRequest);
<span class="hljs-keyword">return</span> chain.proceed(originalRequest);
</code></pre>
<p>从方法名字基本可以猜到是干嘛的，调用 chain.proceed(originalRequest); 将request传递进来，从拦截器链里拿到返回结果。那么拦截器Interceptor是干嘛的，Chain是干嘛的呢？继续往下看RealInterceptorChain</p>
<p>RealInterceptorChain类</p>
<p>下面是RealInterceptorChain的定义，该类实现了Chain接口，在getResponseWithInterceptorChain调用时好几个参数都传的null。</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Chain</span> </span>{

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealInterceptorChain</span><span class="hljs-params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,
        HttpCodec httpCodec, RealConnection connection, <span class="hljs-keyword">int</span> index, Request request)</span> </span>{
        <span class="hljs-keyword">this</span>.interceptors = interceptors;
        <span class="hljs-keyword">this</span>.connection = connection;
        <span class="hljs-keyword">this</span>.streamAllocation = streamAllocation;
        <span class="hljs-keyword">this</span>.httpCodec = httpCodec;
        <span class="hljs-keyword">this</span>.index = index;
        <span class="hljs-keyword">this</span>.request = request;
  }
  ......

 <span class="hljs-meta">@Override</span> 
 <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
      RealConnection connection)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();

    calls++;

    ......

    <span class="hljs-comment">// Call the next interceptor in the chain.</span>
    RealInterceptorChain next = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, streamAllocation, httpCodec, connection, index + <span class="hljs-number">1</span>, request);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

   ......

    <span class="hljs-keyword">return</span> response;
  }

  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p>主要看proceed方法，proceed方法中判断index（此时为0）是否大于或者等于client.interceptors(List )的大小。由于httpStream为null，所以首先创建next拦截器链，主需要把索引置为index+1即可；然后获取第一个拦截器，调用其intercept方法。</p>
<p>Interceptor 代码如下：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>{
  <span class="hljs-function">Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException</span>;

  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Chain</span> </span>{
    <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException</span>;

    <span class="hljs-function">Connection <span class="hljs-title">connection</span><span class="hljs-params">()</span></span>;
  }
}
</code></pre>
<p>BridgeInterceptor</p>
<p>BridgeInterceptor从用户的请求构建网络请求，然后提交给网络，最后从网络响应中提取出用户响应。从最上面的图可以看出，BridgeInterceptor实现了适配的功能。下面是其intercept方法：</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>{
  ......

<span class="hljs-meta">@Override</span> 
<span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>{
  Request userRequest = chain.request();
  Request.Builder requestBuilder = userRequest.newBuilder();

 RequestBody body = userRequest.body();
 <span class="hljs-comment">//如果存在请求主体部分，那么需要添加Content-Type、Content-Length首部</span>
 <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) {
      MediaType contentType = body.contentType();
      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) {
        requestBuilder.header(<span class="hljs-string">"Content-Type"</span>, contentType.toString());
      }

      <span class="hljs-keyword">long</span> contentLength = body.contentLength();
      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) {
        requestBuilder.header(<span class="hljs-string">"Content-Length"</span>, Long.toString(contentLength));
        requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);
      } <span class="hljs-keyword">else</span> {
        requestBuilder.header(<span class="hljs-string">"Transfer-Encoding"</span>, <span class="hljs-string">"chunked"</span>);
        requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);
      }
    }

    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Host"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"Host"</span>, hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));
    }

    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Connection"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"Keep-Alive"</span>);
    }

    <span class="hljs-comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span>
    <span class="hljs-comment">// the transfer stream.</span>
    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Accept-Encoding"</span>) == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">"Range"</span>) == <span class="hljs-keyword">null</span>) {
      transparentGzip = <span class="hljs-keyword">true</span>;
      requestBuilder.header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>);
    }

    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());
    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) {
      requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));
    }

  <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"User-Agent"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"User-Agent"</span>, Version.userAgent());
  }

Response networkResponse = chain.proceed(requestBuilder.build());

HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());

Response.Builder responseBuilder = networkResponse.newBuilder()
        .request(userRequest);

    <span class="hljs-keyword">if</span> (transparentGzip
        &amp;&amp; <span class="hljs-string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">"Content-Encoding"</span>))
        &amp;&amp; HttpHeaders.hasBody(networkResponse)) {
      GzipSource responseBody = <span class="hljs-keyword">new</span> GzipSource(networkResponse.body().source());
      Headers strippedHeaders = networkResponse.headers().newBuilder()
          .removeAll(<span class="hljs-string">"Content-Encoding"</span>)
          .removeAll(<span class="hljs-string">"Content-Length"</span>)
          .build();
      responseBuilder.headers(strippedHeaders);
      responseBuilder.body(<span class="hljs-keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
    }

    <span class="hljs-keyword">return</span> responseBuilder.build();
  }

  <span class="hljs-comment">/** Returns a 'Cookie' HTTP request header with all cookies, like {<span class="hljs-doctag">@code</span> a=b; c=d}. */</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">cookieHeader</span><span class="hljs-params">(List&lt;Cookie&gt; cookies)</span> </span>{
    StringBuilder cookieHeader = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cookies.size(); i &lt; size; i++) {
      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
        cookieHeader.append(<span class="hljs-string">"; "</span>);
      }
      Cookie cookie = cookies.get(i);
      cookieHeader.append(cookie.name()).append(<span class="hljs-string">'='</span>).append(cookie.value());
    }
    <span class="hljs-keyword">return</span> cookieHeader.toString();
  }
}
</code></pre>
<p>从上面的代码可以看出，首先获取原请求，然后在请求中添加头，比如Host、Connection、Accept-Encoding参数等，然后根据看是否需要填充Cookie，在对原始请求做出处理后，使用chain的procced方法得到响应，接下来对响应做处理得到用户响应，最后返回响应。接下来再看下一个拦截器ConnectInterceptor的处理。</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>{
  ......

 <span class="hljs-meta">@Override</span> 
 <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>{
 RealInterceptorChain realChain = (RealInterceptorChain) chain;
Request request = realChain.request();
StreamAllocation streamAllocation = realChain.streamAllocation();

 <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>
 <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);
 HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
 RealConnection connection = streamAllocation.connection();

 <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);
  }
}
</code></pre>
<p>实际上建立连接就是创建了一个 HttpCodec 对象，它利用 Okio 对 Socket 的读写操作进行封装，Okio 以后有机会再进行分析，现在让我们对它们保持一个简单地认识：它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作。</p>
<p>CallServerInterceptor</p>
<p>CallServerInterceptor是拦截器链中最后一个拦截器，负责将网络请求提交给服务器。它的intercept方法实现如下：</p>
<pre class="hljs java"><code class="java"><span class="hljs-meta">@Override</span> 
<span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    HttpCodec httpCodec = realChain.httpStream();
    StreamAllocation streamAllocation = realChain.streamAllocation();
    RealConnection connection = (RealConnection) realChain.connection();
    Request request = realChain.request();

    <span class="hljs-keyword">long</span> sentRequestMillis = System.currentTimeMillis();
    httpCodec.writeRequestHeaders(request);

    Response.Builder responseBuilder = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span>
      <span class="hljs-comment">// Continue" response before transmitting the request body. If we don't get that, return what</span>
      <span class="hljs-comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="hljs-string">"Expect"</span>))) {
        httpCodec.flushRequest();
        responseBuilder = httpCodec.readResponseHeaders(<span class="hljs-keyword">true</span>);
      }

      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span>
        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
        request.body().writeTo(bufferedRequestBody);
        bufferedRequestBody.close();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!connection.isMultiplexed()) {
        <span class="hljs-comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span>
        <span class="hljs-comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span>
        <span class="hljs-comment">// connection in a consistent state.</span>
        streamAllocation.noNewStreams();
      }
    }

    httpCodec.finishRequest();

    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) {
      responseBuilder = httpCodec.readResponseHeaders(<span class="hljs-keyword">false</span>);
    }

    Response response = responseBuilder
        .request(request)
        .handshake(streamAllocation.connection().handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build();

    <span class="hljs-keyword">int</span> code = response.code();
    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) {
      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span>
      response = response.newBuilder()
          .body(Util.EMPTY_RESPONSE)
          .build();
    } <span class="hljs-keyword">else</span> {
      response = response.newBuilder()
          .body(httpCodec.openResponseBody(response))
          .build();
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">"Connection"</span>))
        || <span class="hljs-string">"close"</span>.equalsIgnoreCase(response.header(<span class="hljs-string">"Connection"</span>))) {
      streamAllocation.noNewStreams();
    }

    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(
          <span class="hljs-string">"HTTP "</span> + code + <span class="hljs-string">" had non-zero Content-Length: "</span> + response.body().contentLength());
    }

    <span class="hljs-keyword">return</span> response;
  }
</code></pre>
<p>从上面的代码中可以看出，首先获取HttpStream对象，然后调用writeRequestHeaders方法写入请求的头部，然后判断是否需要写入请求的body部分，最后调用finishRequest()方法将所有数据刷新给底层的Socket，接下来尝试调用readResponseHeaders()方法读取响应的头部，然后再调用openResponseBody()方法得到响应的body部分，最后返回响应。</p>
<h3>最后总结</h3>
<p>OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。而OkHttp对Socket的读写操作使用的OkIo库进行了一层封装。</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 1120px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 160.0%;"></div>
<div class="image-view" data-width="1000" data-height="1600"><img data-original-src="//upload-images.jianshu.io/upload_images/4037105-dc97d1a43aed5334" data-original-width="1000" data-original-height="1600" data-original-format="image/png" data-original-filesize="78180" style="cursor: zoom-in;" class="" src="//upload-images.jianshu.io/upload_images/4037105-dc97d1a43aed5334?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></div>
</div>
<div class="image-caption"></div>
</div>
<ul>
<div class="image-package">
<div class="image-container" style="max-width: 129px; max-height: 129px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 100.0%;"></div>
<div class="image-view" data-width="129" data-height="129"><img data-original-src="//upload-images.jianshu.io/upload_images/4037105-8f737b5104dd0b5d.png" data-original-width="129" data-original-height="129" data-original-format="image/png" data-original-filesize="18106" style="cursor: zoom-in;" class="" src="https://upload-images.jianshu.io/upload_images/4037105-8f737b5104dd0b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/129/format/webp"></div>
</div>
<div class="image-caption"></div>
</div>


