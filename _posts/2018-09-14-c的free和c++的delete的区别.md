---
layout: post
title: "c的free和c++的delete的区别"
date: 2018-09-14
catalog: true
tags:
      - C
      - C++
      - free
      - delete
---



首先free对应的是malloc；delete对应的是new；free用来释放malloc出来动态内存，delete用来释放new出来的动态内存空间。

应用的区别为：

1. 数组的时候int *p=(int*)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。

2. 在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。

共同之处：

它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。

 ![][]

在这里关于指针和动态申请的内存空间总结如下：

1.      指针消亡了，并不表示它指示的动态内存会自动释放；

2.      动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数；

动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。
[]: 
