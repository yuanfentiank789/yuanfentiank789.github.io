---
layout: post
title:  C语言复杂表达式与指针高级应用
date:   2018-10-29 1:05:00
catalog:  true
tags:
    - JNI
    - 内存泄漏    
       

---

# C语言复杂表达式与指针高级应用

## 第一部分、章节目录
- 4.4.1.指针数组与数组指针
- 4.4.2.函数指针与typedef
- 4.4.3.函数指针实战1
- 4.4.4.函数指针实战2
- 4.4.5.再论typedef
- 4.4.6.二重指针
- 4.4.7.二维数组
- 4.4.8.二维数组的运算和指针

## 第二部分、章节介绍
### 4.4.1.指针数组与数组指针
本节讲述2个很容易搞混淆的C语言复杂符号：指针数组与数组指针。并且希望通过这两个“入门级”的复杂符号引入C语言复杂表达式的解析方法。
### 4.4.2.函数指针与typedef
本节讲述函数指针这个更为复杂些的C语言复杂表达式，使用上节介绍过的方法来解析函数指针，让大家再次复习这种非常有效的分析方法。并且引入typedef关键。
### 4.4.3.函数指针实战1
本节进行函数指针的实战编程练习1，通过编写一个计算器程序，让大家体会函数指针的常规用法，并且指出其中隐含的面向对象的思维方式。
### 4.4.4.函数指针实战2
本节继续进行函数指针的实战编程练习2，是一个比较复杂的分层结构下用函数指针实现架构的案例，linux内核驱动中广泛使用了这种技巧。
### 4.4.5.再论typedef
本节详细系统的讲述typedef的惯用法和应用目的，除了整理之前提到的内容外，重点讲了typedef与结构体、typedef与const这两个新知识点。
### 4.4.6.二重指针
本节讲述二重指针，通过代码实例让大家明白二重指针的本质，从而更加明白指针变量的本质。通过示例讲了二重指针的几种常见应用方法，二重指针和指针数组的关系等。

### 4.4.7.二维数组
本节讲解二维数组，首先从内存角度分析二维数组，然后从下标访问和指针访问的角度分别访问数组元素，试图让大家理解二维数组的本质。
### 4.4.8.二维数组的运算和指针
本节将二维数组和指针结合起来，通过一些题目运算让大家了解二维数组和指针之间的一些运算规律，这也是在现实编程中困扰大家最多的地方。

## 第三部分、随堂记录
### 4.4.1.指针数组与数组指针
#### 4.4.1.1、字面意思来理解指针数组与数组指针
(1)指针数组的实质是一个数组，这个数组中存储的内容全部是指针变量。
(2)数组指针的实质是一个指针，这个指针指向的是一个数组。
#### 4.4.1.2、分析指针数组与数组指针的表达式
(1)int *p[5]; int (*p)[5];	int *(p[5]);
(2)一般规律：int *p;(p是一个指针)； int p[5];(p是一个数组)
总结：我们在定义一个符号时，关键在于：首先要搞清楚你定义的符号是谁（第一步：找核心）；其次再来看谁跟核心最近、谁跟核心结合（第二步：找结合）；以后继续向外扩展（第三步：继续向外结合直到整个符号完）。
(3)如何核心和*结合，表示核心是指针；如果核心和[]结合，表示核心是数组；如果核心和()结合，表示核心是函数。
(4)用一般规律来分析3个符号：
第一个：int *p[5]; 核心是p，p是一个数组，数组有5个元素大，数组中的元素都是指针，指针指向的元素类型是int类型的；整个符号是一个指针数组。
第二个，int (*p)[5];
核心是p，p是一个指针，指针指向一个数组，数组有5个元素，数组中存的元素是int类型； 总结一下整个符号的意义就是数组指针。
第三个，int *(p[5]); 
解析方法和结论和第一个相同，()在这里是可有可无的。

注意：符号的优先级到底有什么用？其实是决定当2个符号一起作用的时候决定哪个符号先运算，哪个符号后运算。
遇到优先级问题怎么办？第一，查优先级表；第二，自己记住（全部记住都成神了，人只要记住[] . ->这几个优先级比较好即可）。

#### 4.4.1.3、总结1：优先级和结合性是分析符号意义的关键
(1)在分析C语言问题时不要胡乱去猜测规律，不要总觉得c语言无从捉摸，从已知的规律出发按照既定的规则去做即可。
#### 4.4.1.4、总结2：学会逐层剥离的分析方法
(1)找到核心后从内到外逐层的进行结合，结合之后可以把已经结合的部分当成一个整体，再去和整体外面的继续进行结合。
#### 4.4.1.5、总结3：基础理论和原则是关键，没有无缘无故的规则

### 4.4.2.函数指针与typedef
#### 4.4.2.1、函数指针的实质（还是指针变量）
(1)函数指针的实质还是指针，还是指针变量。本身占4字节（在32位系统中，所有的指针都是4字节）
(2)函数指针、数组指针、普通指针之间并没有本质区别，区别在于指针指向的东西是个什么玩意。
(3)函数的实质是一段代码，这一段代码在内存中是连续分布的（一个函数的大括号括起来的所有语句将来编译出来生成的可执行程序是连续的），所以对于函数来说很关键的就是函数中的第一句代码的地址，这个地址就是所谓的函数地址，在C语言中用函数名这个符号来表示。
(4)结合函数的实质，函数指针其实就是一个普通变量，这个普通变量的类型是函数指针变量类型，它的值就是某个函数的地址（也就是它的函数名这个符号在编译器中对应的值）

#### 4.4.2.2、函数指针的书写和分析方法
(1)C语言本身是强类型语言（每一个变量都有自己的变量类型），编译器可以帮我们做严格的类型检查。
(2)所有的指针变量类型其实本质都是一样的，但是为什么在C语言中要去区分它们，写法不一样呢（譬如int类型指针就写作int *p; 数组指针就写作int (*p)[5]，函数指针就得写得更复杂）
(3)假设我们有个函数是：void func(void); 对应的函数指针：void (*p)(void); 类型是：void (*)(void);
(4)函数名和数组名最大的区别就是：函数名做右值时加不加&效果和意义都是一样的；但是数组名做右值时加不加&意义就不一样。
(5)写一个复杂的函数指针的实例：譬如函数是strcpy函数（char *strcpy(char *dest, const char *src);），对应的函数指针是：char *(*pFunc)(char *dest, const char *src);

#### 4.4.2.3、typedef关键字的用法
- (1)typedef是C语言中一个关键字，作用是用来定义（或者叫重命名类型）
- (2)C语言中的类型一共有2种：一种是编译器定义的原生类型（基础数据类型，如int、double之类的）；第二种是用户自定义类型，不是语言自带的是程序员自己定义的（譬如数组类型、结构体类型、函数类型·····）。
- (3)我们今天讲的数组指针、指针数组、函数指针等都属于用户自定义类型。
- (4)有时候自定义类型太长了，用起来不方便，所以用typedef给它重命名一个短点的名字。
- (5)注意：typedef是给类型重命名，也就是说typedef加工出来的都是类型，而不是变量。

#### 4.4.2.4、总结：函数指针的分析方法也是源于优先级与逐层剥离的基本理论

### 4.4.3.函数指针实战1
#### 4.4.3.1、用函数指针调用执行函数
(1)最简单的函数指针来调用函数的示例，在上节课中已经演示过了。
(2)本节演示的是用函数指针指向不同的函数来实现同一个调用执行不同的结果。
(3)如果学过C++或者Java或者C#等面向对象的语言，就会知道面向对象三大特征中有一个多态。多态就是同一个执行实际结果不一样，跟我们这里看到的现象其实是一样的。
(4)刚才的调试过程，可以得到很多信息：

- 第一：当程序出现段错误时，第一步先定位段错误。定位的方法就是在可疑处加打印信息，从而锁定导致段错误的语句，然后集中分析这句为什么会段错误。
- 第二：linux中命令行默认是行缓冲的，意思就是说当我们程序printf输出的时候，linux不会一个字一个字的输出我们的内容，而是将其缓冲起来放在缓冲区等一行准备完了再一次性把一行全部输出出来（为了效率）。linux判断一行有没有完的依据就是换行符'\n'（windows中换行符是\r\n, linux中是\n，iOS中是\r）。也就是说你printf再多，只要没有遇到\n（或者程序终止，或者缓冲区满）都不会输出而会不断缓冲，这时候你是看不到内容输出的。因此，在每个printf打印语句（尤其是用来做调试的printf语句）后面一定要加\n，否则可能导致误判。
- 第三：关于在linux命令行下用scanf写交互性代码的问题，想说以下几点：
  - 1. 命令行下的交互程序纯粹是用来学习编程用的，几乎没有实践意义，大家别浪费时间了。
  - 2. scanf是和系统的标准输入打交道，printf和标准输出打交道。要完全搞清楚这些东西得把标准输入标准输出搞清楚。
 - 3. 我们用户在输入内容时结尾都会以\n结尾，但是程序中scanf的时候都不会去接收最后的\n，导致这个回车符还存留在标准输入中。下次再scanf时就会先被拿出来，这就导致你真正想拿的那个数反而没机会拿，导致错误。
 
#### 4.4.3.2 代码实例
 
```
#include <stdlib.h>
#include <stdio.h>

//定义了一个类型pFUnc，该函数指针指向一种特定参数列表和返回值的函数
typedef int (*pFunc)(int, int);

int add(int x, int y);

int sub(int x, int y);

int mul(int x, int y);

int divide(int x, int y);

int main() {
    printf("%s\n", "hhh");
    pFunc p1 = NULL;

    char c = 0;
    int a = 0;
    int b = 0;
    int result = 0;
    printf("请输入要操作的两个整数：\n");
    scanf("%d,%d", &a, &b);
    printf("请输入操作类型：+ | - | * | /\n");
    do {
        scanf("%c", &c);
    }while ((c == '\r') || (c == '\n'));
    switch (c) {
        case '+':
            p1 = add;
            break;
        case '-':
            p1 = sub;
            break;
        case '*':
            p1 = mul;
            break;
        case '/':
            p1 = divide;
            break;
        default:
            p1 = NULL;

    }
    if (p1 != NULL) {
        result = p1(a, b);
    } else {
        printf("p1 is null\n");
    }
    printf("%d %c %d = %d\n", a, c, b, result);
    return 0;

}
int add(int x, int y) {
    return x + y;
}

int sub(int x, int y) {
    return x - y;
}

int mul(int x, int y) {
    return x * y;
}

int divide(int x, int y) {
    return x / y;
}

```

### 4.4.4.函数指针实战2
主题：结构体内嵌函数指针实现分层
(1)程序为什么要分层？因为复杂程序东西太多一个人搞不定，需要更多人协同工作，于是乎就要分工。要分工先分层，分层之后各个层次由不同的人完成，然后再彼此调用组合共同工作。
(2)本程序要完成一个计算器，我们设计了2个层次：上层是framework.c，实现应用程序框架；下层是cal.c，实现计算器。实际工作时cal.c是直接完成工作的，但是cal.c中的关键部分是调用的framework.c中的函数来完成的。
(3)先写framework.c，由一个人来完成。这个人在framework.c中需要完成计算器的业务逻辑，并且把相应的接口写在对应的头文件中发出来，将来别的层次的人用这个头文件来协同工作。
(4)另一个人来完成cal.c，实现具体的计算器；这个人需要framework层的工作人员提供头文件来工作（但是不需要framework.c）
(5)总结：
第一：本节和上节实际完成的是同一个习题，但是采用了不同的程序架构。
第二：对于简单问题来说，上节的不分层反而容易理解，反而简单；本节的分层代码不好理解，看起来有点把简单问题复杂化的意思。原因在于我们这个问题本身确实是简单问题，而简单问题就应该用简单方法处理。我们为什么明知错误还要这样做？目的是向大家演示这种分层的写代码的思路和方法。
第三：分层写代码的思路是：有多个层次结合来完成任务，每个层次专注各自不同的领域和任务；不同层次之间用头文件来交互。
第四：分层之后上层为下层提供服务，上层写的代码是为了在下层中被调用。
第五：上层注重业务逻辑，与我们最终的目标相直接关联，而没有具体干活的函数。
第六：下层注重实际干活的函数，注重为上层填充变量，并且将变量传递给上层中的函数（其实就是调用上层提供的接口函数）来完成任务。
第七：下层代码中其实核心是一个结构体变量（譬如本例中的struct cal_t），写下层代码的逻辑其实很简单：第一步先定义结构体变量；第二步填充结构体变量；第三步调用上层写好的接口函数，把结构体变量传给它既可。

### 4.4.5.再论typedef
#### 4.4.5.1、C语言的2种类型：内建类型与用户自定义类型
(1)内建类型ADT、自定义类型UDT
#### 4.4.5.2、typedef定义（或者叫重命名）类型而不是变量
(1)类型是一个数据模板，变量是一个实在的数据。类型是不占内存的，而变量是占内存的。
(2)面向对象的语言中：类型就是类class，变量就是对象。
#### 4.4.5.3、typedef与#define宏的区别

```
typedef char *pChar;//新类型在后边
#define pChar char *//宏在后边
```

#### 4.4.5.4、typedef与结构体
(1)结构体在使用时都是先定义结构体类型，再用结构体类型去定义变量。

```
struct student{
    int age;
    char name[];
};
struct student s1;//定义这种类型要有struct关键字
student s2;//发现C++可以支持这种形式
```

(2)C语言语法规定，结构体类型使用时必须是struct 结构体类型名 结构体变量名;这样的方式来定义变量。
(3)使用typedef一次定义2个类型，分别是结构体变量类型，和结构体变量指针类型。

```
typedef  struct teacher{
    int age;
    char name[];
}teacher_t ;//定义新类型teacher_t,该名字也可与结构体名字相同

```
一次定义2个类型：

```
typedef  struct teacher{
    int age;
    char name[];
}teacher_t,*pTeacher ;//名字也可与结构体名字相同,pTeacher之前的部分看作一个整体，也就是teacher_t类型的指针，等价于pTeacher
```


#### 4.4.5.5、typedef与const
(1)typedef int *PINT;	

   ```
int main(void){
    int a = 10;
    int b  =20;
    const PINT p = &a;
    *p = 15;
    p = &b;//error: read-only variable is not assignable
}
   ```
结论：const PINT p2; //相当于是int *const p2;
(2)typedef int *PINT;	

```
int main(void){

    int a = 10;
    int b  =20;
     PINT const p = &a;
    *p = 15;
    p = &b;//error: read-only variable is not assignable
}

```
结论：PINT const p2; //也相当于是int *const p2;
(3)如果确实想得到const int *p;这种效果(p指向的内容不可修改)，只能typedef const int *CPINT; CPINT p1;

```
typedef const int *PINT;

int main(void){

    int a = 10;
    int b  =20;
     PINT  p = &a;
    *p = 15;////error: read-only variable is not assignable
    p = &b;
}
```

#### 4.4.5.6、使用typedef的重要意义（2个：简化类型、创造平台无关类型）
(1)简化类型的描述。

```
char *(*)(char *, char *);	
typedef char *(*pFunc)(char *, char *);//定义函数指针类型，简化名称
```
   	
(2)创造平台无关类型
很多编程体系下，人们倾向于不使用int、double等C语言内建类型，因为这些类型本身和平台是相关的（譬如int在16位机器上是16位的，在32位机器上就是32位的）。为了解决这个问题，很多程序使用自定义的中间类型来做缓冲。譬如linux内核中大量使用了这种技术.
内核中先定义：typedef int size_t; 然后在特定的编码需要下用size_t来替代int（一旦平台移植，只修改为size_t在新平台合适的类型即可）

(3)STM32的库中全部使用了自定义类型
  譬如typedef volatile unsigned int vu32;


### 4.4.6.二重指针
#### 4.4.6.1、二重指针与普通一重指针的区别
(1)本质上来说，二重指针和一重指针的本质都是指针变量，指针变量的本质就是变量。
(2)一重指针变量和二重指针变量本身都占4字节内存空间，
#### 4.4.6.2、二重指针的本质
(1)二重指针本质上也是指针变量，和普通指针的差别就是它指向的变量类型必须是个一重指针。二重指针其实也是一种数据类型，编译器在编译时会根据二重指针的数据类型来做静态类型检查，一旦发现运算时数据类型不匹配编译器就会报错。
(2)C语言中如果没有二重指针行不行？其实是可以的。一重指针完全可以做二重指针做的事情，之所以要发明二重指针（函数指针、数组指针），就是为了让编译器了解这个指针被定义时定义它的程序员希望这个指针被用来指向什么东西（定义指针时用数据类型来标记，譬如int *p，就表示p要指向int型数据），编译器知道指针类型之后可以帮我们做静态类型检查。编译器的这种静态类型检查可以辅助程序员发现一些隐含性的编程错误，这是C语言给程序员提供的一种编译时的查错机制。
(3)为什么C语言需要发明二重指针？原因和发明函数指针、数组指针、结构体指针等一样的。
#### 4.4.6.3、二重指针的用法
(1)二重指针指向一重指针的地址
(2)二重指针指向指针数组的
(3)实践编程中二重指针用的比较少，大部分时候就是和指针数组纠结起来用的。
(4)实践编程中有时在函数传参时为了通过函数内部改变外部的一个指针变量，会传这个指针变量的地址（也就是二重指针）进去

#### 4.4.6.4、二重指针与数组指针
(1)二重指针、数组指针、结构体指针、一重指针、普通变量的本质都是相同的，都是变量。
(2)所有的指针变量本质都是相同的，都是4个字节，都是用来指向别的东西的，不同类型的指针变量只是可以指向的（编译器允许你指向的）变量类型不同。
(3)二重指针就是：指针数组指针


### 4.4.7.二维数组
#### 4.4.7.1、二维数组的内存映像
(1)一维数组在内存中是连续分布的多个内存单元组成的，而二维数组在内存中也是连续分布的多个内存单元组成的。
(1)从内存角度来看，一维数组和二维数组没有本质差别。
(2)二维数组int a[2][5]和一维数组int b[10]其实没有任何本质差别。我们可以把两者的同一单元的对应关系写下来。
a[0][0]	 a[0][1]   a[0][4]	 a[1][0]	a[1][1]	  a[1][4]	
b[0]	 b[1]	   b[4]	     b[5]	    b[6]	  b[9]
(3)既然二维数组都可以用一维数组来表示，那二维数组存在的意义和价值在哪里？明确告诉大家：二维数组a和一维数组b在内存使用效率、访问效率上是完全一样的（或者说差异是忽略不计的）。在某种情况下用二维数组而不用一维数组，原因在于二维数组好理解、代码好写、利于组织。
(4)总结：我们使用二维数组（C语言提供二维数组），并不是必须，而是一种简化编程的方式。想一下，一维数组的出现其实也不是必然的，也是为了简化编程。

#### 4.4.7.2、哪个是第一维哪个是第二维？
(1)二维数组int a[2][5]中，2是第一维，5是第二维。
(2)结合内存映像来理解二维数组的第一维和第二维的意义。首先第一维是最外面一层的数组，所以int a[2][5]这个数组有2个元素；其中每一个元素又是一个含有5个元素的数组（这个数组就是第二维）。
(3)总结：二维数组的第一维是最外部的那一层，第一维本身是个数组，这个数组中存储的元素也是个数组；二维数组的第二维是里面的那一层，第二维本身是个数组，数组中存的元素是普通元素，第二维这个数组本身作为元素存储在第一维的数组中。

#### 4.4.7.3、二维数组的下标式访问和指针式访问
(1)回顾：一维数组的两种访问方式。以int b[10]为例, int *p = b;。
b[0] 等同于 *(p+0);   b[9] 等同于 *(p+9);  b[i] 等同于 *(p+i)
(2)二维数组的两种访问方式：以int a[2][5]为例，(合适类型的)p = a;
a[0][0]等同于*(*(p+0)+0); 	a[i][j]等同于 *(*(p+i)+j)

#### 4.4.7.4、二维数组的应用和更多维数组
(1)最简单情况，有10个学生成绩要统计；如果这10个学生没有差别的一组，就用b[10]；如果这10个学生天然就分为2组，每组5个，就适合用int a[2][5]来管理。
(2)最常用情况：一维数组用来表示直线，二维数组用来描述平面。数学上，用平面直角坐标系来比拟二维数组就很好理解了。
(3)三维数组和三维坐标系来比拟理解。三维数组其实就是立体空间。
(4)四维数组也是可以存在的，但是数学上有意义，现在空间中没有对应（因为人类生存的宇宙是三维的）。
总结：一般常用最多就到二维数组，三维数组除了做一些特殊与数学运算有关的之外基本用不到。（四轴飞行器中运算飞行器角度、姿态时就要用到三维数组）


### 4.4.8.二维数组的运算和指针
#### 4.4.8.1、指针指向二维数组的数组名
(1)二维数组的数组名表示二维数组的第一维数组中首元素（也就是第二维的数组）的首地址
(2)二维数组的数组名a等同于&a[0]，这个和一维数组的符号含义是相符的。
(3)用数组指针来指向二维数组的数组名是类型匹配的。

#### 4.4.8.2、指针指向二维数组的第一维
(1)用int *p来指向二维数组的第一维a[i]

#### 4.4.8.3、指针指向二维数组的第二维
(1)二维数组的第二维元素其实就是普通变量了（a[1][1]其实就是int类型的7），已经不能用指针类型和它相互赋值了。
(2)除非int *p = &a[i][j];，类似于指针指向二维数组的第一维。

#### 总结：
二维数组和指针的纠葛，关键就是2点：
1、数组中各个符号的含义。
2、数组的指针式访问，尤其是二维数组的指针式访问。

